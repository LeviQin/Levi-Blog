{"version":3,"file":"index.umd.min.js","sources":["../index.js"],"sourcesContent":["let browserSupportsTextareaTextNodes;\n\n/**\n * @param {HTMLElement} input\n * @return {boolean}\n */\nfunction canManipulateViaTextNodes(input) {\n  if (input.nodeName !== \"TEXTAREA\") {\n    return false;\n  }\n  if (typeof browserSupportsTextareaTextNodes === \"undefined\") {\n    const textarea = document.createElement(\"textarea\");\n    textarea.value = 1;\n    browserSupportsTextareaTextNodes = !!textarea.firstChild;\n  }\n  return browserSupportsTextareaTextNodes;\n}\n\n/**\n * @param {HTMLTextAreaElement|HTMLInputElement} input\n * @param {string} text\n * @returns {void}\n */\nexport default function(input, text) {\n  // Most of the used APIs only work with the field selected\n  input.focus();\n\n  // IE 8-10\n  if (document.selection) {\n    const ieRange = document.selection.createRange();\n    ieRange.text = text;\n\n    // Move cursor after the inserted text\n    ieRange.collapse(false /* to the end */);\n    ieRange.select();\n\n    return;\n  }\n\n  // Webkit + Edge\n  const isSuccess = document.execCommand(\"insertText\", false, text);\n  if (!isSuccess) {\n    const start = input.selectionStart;\n    const end = input.selectionEnd;\n    // Firefox (non-standard method)\n    if (typeof input.setRangeText === \"function\") {\n      input.setRangeText(text);\n    } else {\n      // To make a change we just need a Range, not a Selection\n      const range = document.createRange();\n      const textNode = document.createTextNode(text);\n\n      if (canManipulateViaTextNodes(input)) {\n        let node = input.firstChild;\n\n        // If textarea is empty, just insert the text\n        if (!node) {\n          input.appendChild(textNode);\n        } else {\n          // Otherwise we need to find a nodes for start and end\n          let offset = 0;\n          let startNode = null;\n          let endNode = null;\n\n          while (node && (startNode === null || endNode === null)) {\n            const nodeLength = node.nodeValue.length;\n\n            // if start of the selection falls into current node\n            if (start >= offset && start <= offset + nodeLength) {\n              range.setStart((startNode = node), start - offset);\n            }\n\n            // if end of the selection falls into current node\n            if (end >= offset && end <= offset + nodeLength) {\n              range.setEnd((endNode = node), end - offset);\n            }\n\n            offset += nodeLength;\n            node = node.nextSibling;\n          }\n\n          // If there is some text selected, remove it as we should replace it\n          if (start !== end) {\n            range.deleteContents();\n          }\n        }\n      }\n\n      // If the node is a textarea and the range doesn't span outside the element\n      //\n      // Get the commonAncestorContainer of the selected range and test its type\n      // If the node is of type `#text` it means that we're still working with text nodes within our textarea element\n      // otherwise, if it's of type `#document` for example it means our selection spans outside the textarea.\n      if (\n        canManipulateViaTextNodes(input) &&\n        range.commonAncestorContainer.nodeName === \"#text\"\n      ) {\n        // Finally insert a new node. The browser will automatically split start and end nodes into two if necessary\n        range.insertNode(textNode);\n      } else {\n        // If the node is not a textarea or the range spans outside a textarea the only way is to replace the whole value\n        const value = input.value;\n        input.value = value.slice(0, start) + text + value.slice(end);\n      }\n    }\n\n    // Correct the cursor position to be at the end of the insertion\n    input.setSelectionRange(start + text.length, start + text.length);\n\n    // Notify any possible listeners of the change\n    const e = document.createEvent(\"UIEvent\");\n    e.initEvent(\"input\", true, false);\n    input.dispatchEvent(e);\n  }\n}\n"],"names":["browserSupportsTextareaTextNodes","canManipulateViaTextNodes","input","nodeName","textarea","document","createElement","value","firstChild","text","focus","selection","ieRange","createRange","collapse","select","execCommand","start","selectionStart","end","selectionEnd","setRangeText","range","textNode","createTextNode","node","offset","startNode","endNode","nodeLength","nodeValue","length","setStart","setEnd","nextSibling","deleteContents","appendChild","commonAncestorContainer","insertNode","slice","setSelectionRange","e","createEvent","initEvent","dispatchEvent"],"mappings":"wMAAA,IAAIA,EAMJ,SAASC,EAA0BC,MACV,aAAnBA,EAAMC,gBACD,UAEuC,IAArCH,EAAkD,KACrDI,EAAWC,SAASC,cAAc,YACxCF,EAASG,MAAQ,EACjBP,IAAqCI,EAASI,kBAEzCR,SAQM,SAASE,EAAOO,MAE7BP,EAAMQ,QAGFL,SAASM,UAAW,KAChBC,EAAUP,SAASM,UAAUE,qBACnCD,EAAQH,KAAOA,EAGfG,EAAQE,UAAS,QACjBF,EAAQG,aAMQV,SAASW,YAAY,cAAc,EAAOP,GAC5C,KACRQ,EAAQf,EAAMgB,eACdC,EAAMjB,EAAMkB,gBAEgB,mBAAvBlB,EAAMmB,aACfnB,EAAMmB,aAAaZ,OACd,KAECa,EAAQjB,SAASQ,cACjBU,EAAWlB,SAASmB,eAAef,MAErCR,EAA0BC,GAAQ,KAChCuB,EAAOvB,EAAMM,cAGZiB,EAEE,SAEDC,EAAS,EACTC,EAAY,KACZC,EAAU,KAEPH,IAAuB,OAAdE,GAAkC,OAAZC,IAAmB,KACjDC,EAAaJ,EAAKK,UAAUC,OAGrBL,GAATT,GAAmBA,GAASS,EAASG,GACvCP,EAAMU,SAAUL,EAAYF,EAAOR,EAAQS,GAIlCA,GAAPP,GAAiBA,GAAOO,EAASG,GACnCP,EAAMW,OAAQL,EAAUH,EAAON,EAAMO,GAGvCA,GAAUG,EACVJ,EAAOA,EAAKS,YAIVjB,IAAUE,GACZG,EAAMa,sBA1BRjC,EAAMkC,YAAYb,MAqCpBtB,EAA0BC,IACiB,UAA3CoB,EAAMe,wBAAwBlC,SAG9BmB,EAAMgB,WAAWf,OACZ,KAEChB,EAAQL,EAAMK,MACpBL,EAAMK,MAAQA,EAAMgC,MAAM,EAAGtB,GAASR,EAAOF,EAAMgC,MAAMpB,IAK7DjB,EAAMsC,kBAAkBvB,EAAQR,EAAKsB,OAAQd,EAAQR,EAAKsB,YAGpDU,EAAIpC,SAASqC,YAAY,WAC/BD,EAAEE,UAAU,SAAS,GAAM,GAC3BzC,EAAM0C,cAAcH"}